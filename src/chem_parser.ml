open Core.Std
open Re2

type t = {lhs: formula_t; rhs: formula_t}
and formula_t = molecule_t list
and molecule_t = (atom_t * coeff_t) list
and coeff_t = int
and atom_t = string with sexp

let of_string (input:string) : t option =
    let matches = Regex.(split (of_string (escape "->")) input) in
    match matches with
    | lhs::rhs::[] ->

        (* Splits molecule to atoms. E.g. H2SO4 -> Molecule
         * [(H, 2), (S, 1), (O, 4)] *)
        let atom_splitter (f:string) : molecule_t = List.map
            ~f:(fun m ->
                    Regex.Match.get_exn ~sub:(`Index 1) m,
                    match Regex.Match.get ~sub:(`Index 2) m with
                        | Some "" -> 1
                        | Some x -> Int.of_string x
                        | None -> 1)
            (Regex.get_matches_exn
                (Regex.of_string "([A-Z][a-z]*)([0-9]?)") f
            ) in

        (* Splits the formula to molecules. E.g. H2SO4 + Ca ->
            * [(Molecule ...), (Molecule ...)] *)
        let molecule_splitter (f:string) : formula_t =
            List.map ~f:atom_splitter
                Regex.(split (of_string (escape "+")) f) in
        Some {lhs=molecule_splitter lhs; rhs=molecule_splitter rhs}
    | _ -> None;;

(** Returns a string representation for a number greater than 1 or an empty
 * string otherwise *)
let coeff_to_string = function
    | 1 -> ""
    | c -> string_of_int c

let molecule_to_string (m:molecule_t) =
    let molecule_tokens = List.map m ~f:(
        fun (atom, coeff) ->
            atom ^ coeff_to_string coeff
    ) in
    String.concat molecule_tokens

let to_string (equation:t) : string =
    let formula_to_string (f:formula_t) =
        String.concat ~sep:" + "
            (List.map f ~f:molecule_to_string) in
    sprintf "%s -> %s"
        (formula_to_string equation.lhs)
        (formula_to_string equation.rhs)

(** Type for the equations with coefficients attached *)
module Coeff_equation = struct
    type coeff_t = {lhs_c: coeff_formula_t; rhs_c: coeff_formula_t}
    and coeff_formula_t = (int * molecule_t) list with sexp

    let to_string (equation : coeff_t) : string =
        let formula_to_string (f:coeff_formula_t) : string =
            String.concat ~sep:" + "
                (List.map f ~f:(
                    fun (coeff, molecule) ->
                        coeff_to_string coeff ^ molecule_to_string molecule
                )) in
        sprintf "%s -> %s"
            (formula_to_string equation.lhs_c)
            (formula_to_string equation.rhs_c)
end

module Converter = struct
    module Molecule_var = struct
        type t = molecule_t with sexp
        let to_string = molecule_to_string
    end

    module Number = Rational_number
    module Opt = Opt_solver_f.Make(Molecule_var)(Number)
    module Expression = Opt.Expression
    type output_t = OutputSolution of Coeff_equation.coeff_t | Unsolvable

    let merge_unit_maps = Map.Poly.merge ~f:(fun ~key:_ _ -> Some ())

    let molecule_used_vars (m:molecule_t) =
        Map.Poly.of_alist_exn
            (List.map m ~f:(function (s, _) -> (s, ())))

    let formula_used_vars (f:formula_t) =
        List.fold f ~init:Map.Poly.empty
            ~f:(fun all_vars m ->
                merge_unit_maps all_vars (molecule_used_vars m))

    let equation_used_vars (equation:t) =
        merge_unit_maps
            (formula_used_vars equation.lhs)
            (formula_used_vars equation.rhs)

    let coeff_for_atom_in_molecule (molecule:molecule_t) (atom:atom_t) =
        match List.Assoc.find molecule atom with
            | Some c -> Number.of_int c
            | None -> Number.zero

    let to_opt_problem (equation:t) =
        (* Convert the equation to the set of constraints *)
        (* one constraint per each atom occurring *)
        let used_atoms = equation_used_vars equation in
        Log.debugf "used_atoms = \n%s"
            (String.concat ~sep:", " (Map.Poly.keys used_atoms));

        (* List of constraints generated by the atoms. *)
        let atom_constraints = Map.Poly.fold used_atoms ~init:[] ~f:(
            fun ~key:atom ~data:_ all_constraints ->
                let open Opt.InputConstraintType in

                (* Converts formula to an expression _with respect to_ the given
                 * atom *)
                let formula_to_expression (formula:formula_t) =
                    Expression.of_assoc_list_and_const
                        (List.map formula ~f:(
                            fun molecule -> (
                                molecule,
                                coeff_for_atom_in_molecule molecule atom)
                        ))
                       Number.zero in

                let expr_lhs = formula_to_expression equation.lhs in
                let expr_rhs = formula_to_expression equation.rhs in
                let constr = (EqualZero, Expression.(expr_lhs -- expr_rhs)) in
                constr :: all_constraints
        ) in

        (* Constraints stating that all variables should be strictly greater
         * than zero *)
        let nz_constraints =
            let open Opt.InputConstraintType in
            let all_molecules = equation.lhs @ equation.rhs in
            List.map all_molecules ~f:(
                fun molecule ->
                    (GreaterThanZero, Expression.(
                        (of_var molecule) -- (of_const Number.one)
                    )))
            in
        let constraints = atom_constraints @ nz_constraints in

        (** Minimization objective is just the sum of all used variables. *)
        let objective =
            let open Expression in
            let formula_to_expr (formula:formula_t) =
                List.fold formula
                    ~init:(of_assoc_list_and_const [] Number.zero)
                    ~f:(fun expr molecule -> expr ++ (of_var molecule)) in
            Opt.Minimize
                ((formula_to_expr equation.lhs) ++
                (formula_to_expr equation.rhs))
        in
        Opt.of_constraints_and_objective constraints objective

    (** Convert the solution from rationals to integers. *)
    let vars_to_integers (vars:Opt.var_map_t) =
        (** Convert a list of rationals to integers, by multiplying every
         * rational by the LCM of all denominators. *)
        let to_ints (l : Q.t list) : int list =
            (* LCM for all denominators *)
            let lcm = List.fold l ~init:Z.one ~f:(
                fun lcm n -> Z.lcm lcm Q.(n.den)) in
            (* Multiply all numbers by the lcm, the denominator should become
             * one. *)
            List.map l ~f:(fun n ->
                (* [i] should be an integer after such a multiplication... *)
                let i = Q.(n * (~$$ lcm)) in
                (* ... so we can just convert it to big-integer representation,
                 * and each number should be small enough to fit inside [int]! *)
                Z.to_int Q.(Z.div i.num i.den)) in

        let (vars, values) = List.unzip vars in
        List.zip_exn vars (to_ints values)

    let solution_to_coefficients
            (equation:t)
            (solution:Opt.opt_solution_t)
            : output_t =
        let open Opt in
        match solution with
            | Opt.Solution feasible_solution ->
                (* List, associates each molecule with a number *)
                let int_var_assignment = vars_to_integers
                    feasible_solution.primal_var_assignment in
                let var_map = Map.Poly.of_alist_exn int_var_assignment in
                let formula_coeff_adder
                        (formula:formula_t)
                        : Coeff_equation.coeff_formula_t =
                    List.map formula ~f:(fun molecule ->
                        (Map.Poly.find_exn var_map molecule, molecule)
                    ) in
                OutputSolution Coeff_equation.(
                    {
                        lhs_c=formula_coeff_adder equation.lhs;
                        rhs_c=formula_coeff_adder equation.rhs;
                    }
                )
            | Opt.Unbounded -> failwith
                "Unexpected unbounded: should never arise from the equation"
            | Opt.Unfeasible -> Unsolvable
    let add_coeffs (equation:t) : output_t =
        let opt_problem = to_opt_problem equation in
        solution_to_coefficients equation (Opt.solve opt_problem)
end
